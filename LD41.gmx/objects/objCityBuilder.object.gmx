<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprHouse</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-100</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>enum STRUCTURE {
    ROAD,
    HOUSE,
    FACTORY,
    STORE,
    DESTROY,
}

cellWidth = 32
cellHeight = 32

hoverX = 0
hoverY = 0
okToPlace = false
animT = 0
t = 0
readyToDraw = false

enabled = false

lastPlacedX = 0
lastPlacedY = 0
suppressIndicatorLastPlaced = false
buttonHover = false
backingHover = false
buttonSelected = noone

structure = STRUCTURE.ROAD
structureCost = 0
ghost = instance_create(0, 0, objGhostCityCell)
ghost.image_alpha = 0.5

moneyPerRound = 100
money = moneyPerRound
factoryRevenue = 30
roadCost = 20
houseCost = 20
factoryCost = 50
storeCost = 50

numFactories = 0
population = 0
numIndustryAndCommercial = 0

sprite_index = -1

marioExists = false
luigiExists = false
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Enable self
enabled = true

// Buttons visible
with objBuildButton {
    visible = true
}
with objButtonBacking {
    visible = true
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Factories earn money

with objCityCellFactory {
    if not builtThisPhase {
        objCityBuilder.money += objCityBuilder.factoryRevenue
    
        with instance_create(
        x+objCityBuilder.cellWidth/2,
        y+objCityBuilder.cellHeight/2,
        objText) {
            text = '+$'+string(objCityBuilder.factoryRevenue)
            color = c_lime
            vspeed = -0.25
            destroyT = 60
            halign = fa_center
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if not enabled {
    readyToDraw = false
    suppressIndicatorLastPlaced = false
    t ++
    exit
}

readyToDraw = true
animT ++

// Detect hovering over backing
backingHover = instance_position(mouse_x, mouse_y, objButtonBacking)

var buttonHoverLast = buttonHover

// Which button are we hovering over (if any)?
buttonHover = instance_position(mouse_x, mouse_y, objBuildButton)
// Don't select invisible destroy button
if buttonHover != noone and not buttonHover.visible {
    buttonHover = noone
}

// Click buttons to select structures
if buttonHover != noone and mouse_check_button_pressed(mb_left) {
    if buttonHover.endButton {
        scrEnterShootPhase()
        exit
    } else {
        structure = buttonHover.structure
        buttonSelected = buttonHover
        audio_play_sound(sndMenuClick, 0, false)
    }
}

// Play sound when hovering over a new button
/*if buttonHover != buttonHoverLast and buttonHover != noone {
    audio_play_sound(sndMenuClickHover, 0, false)
}*/


// Update current cost and sprite index based on selected structure
if structure == STRUCTURE.ROAD {
    ghost.sprite_index = sprRoad
    structureCost = roadCost
} else if structure == STRUCTURE.HOUSE {
    ghost.sprite_index = sprHouse
    structureCost = houseCost
} else if structure == STRUCTURE.FACTORY {
    ghost.sprite_index = sprFactory
    structureCost = factoryCost
} else if structure == STRUCTURE.STORE {
    ghost.sprite_index = sprStore
    structureCost = storeCost
} else if structure == STRUCTURE.DESTROY {
    ghost.sprite_index = sprCityCellNoPlace
    structureCost = 0
}

// Compute which cell we're hovering over
hoverX = floor(mouse_x/cellWidth)*cellWidth
hoverY = floor(mouse_y/cellHeight)*cellHeight

var okToPlacePhysical = false
var inFog = false

with ghost {
    // Position ghost
    x = other.hoverX
    y = other.hoverY
    
    // Do collisions checks to see if it's ok to place here
    inFog = not instance_place(x, y, objFogBlocker)
    okToPlacePhysical = not instance_place(x, y, objCityCell)
        and not inFog
        and (instance_place(x+other.cellWidth, y, objCityCellRoad)
        or instance_place(x-other.cellWidth, y, objCityCellRoad)
        or instance_place(x, y+other.cellHeight, objCityCellRoad)
        or instance_place(x, y-other.cellHeight, objCityCellRoad))
    
    // Update road ghost sprite
    image_index = 0
    if other.structure == STRUCTURE.ROAD {
        scrRoadUpdateSprite()
    }
}

// Compute number of buildings and population
population = instance_number(objCityCellHouse)
numIndustryAndCommercial =
    instance_number(objCityCellFactory)
    + instance_number(objCityCellStore)

// Cost and population check
var enoughMoney = other.money &gt;= other.structureCost
var populationOk = numIndustryAndCommercial &lt; population
    or !(structure == STRUCTURE.FACTORY or structure == STRUCTURE.STORE)
okToPlace = okToPlacePhysical and enoughMoney and populationOk
    and structure != STRUCTURE.DESTROY



// Create and destroy buildlings
if not backingHover {
    var success = false
    
    if mouse_check_button_pressed(mb_left) and okToPlace {
        success = true
        
        var cellObj = objCityCell
        if structure == STRUCTURE.ROAD {
            cellObj = objCityCellRoad
            audio_play_sound(sndBuildRoad, 0, false)
        } else if structure == STRUCTURE.HOUSE {
            cellObj = objCityCellHouse
            audio_play_sound(sndBuildHouse, 0, false)
        } else if structure == STRUCTURE.FACTORY {
            cellObj = objCityCellFactory
            audio_play_sound(sndBuildFactory, 0, false)
        } else if structure == STRUCTURE.STORE {
            cellObj = objCityCellStore
            audio_play_sound(sndBuildBakery, 0, false)
        }
        
        // Create the structure, and do special logic depending on what
        // type it is.
        with instance_create(hoverX, hoverY, cellObj) {
            structureType = other.structure
            sprite_index = other.ghost.sprite_index
            
            // Update road sprite
            if other.structure == STRUCTURE.ROAD {
                scrRoadUpdateSprite()
                with instance_place(x-other.cellWidth, y, objCityCellRoad) {
                    scrRoadUpdateSprite()
                }
                with instance_place(x+other.cellWidth, y, objCityCellRoad) {
                    scrRoadUpdateSprite()
                }
                with instance_place(x, y-other.cellHeight, objCityCellRoad) {
                    scrRoadUpdateSprite()
                }
                with instance_place(x, y+other.cellHeight, objCityCellRoad) {
                    scrRoadUpdateSprite()
                }
            
            } else if other.structure == STRUCTURE.HOUSE
            or other.structure == STRUCTURE.FACTORY
            or other.structure == STRUCTURE.STORE {
            
                // Create wall
                wallObj = instance_create(x, y, objWall);
                wallObj.parent = id
                with wallObj {
                    image_xscale = 0.5
                    image_yscale = 0.5
                    x += 8
                    y += 8
                    parent = other.id
                }
                
                // Create fog blocker
                fogBlockerObj = instance_create(
                    x+other.cellWidth/2,
                    y+other.cellHeight/2,
                    objFogBlocker)
                
                // Set building depth
                depth -= y/other.cellHeight
                show_debug_message(depth)
            }
        }
        
        // Hide the X/check indicator until we move our cursor to a different cell
        okToPlace = false
        suppressIndicatorLastPlaced = true
        lastPlacedX = hoverX
        lastPlacedY = hoverY
        
        money -= structureCost
        
        // Money spent floating text
        /*with instance_create(hoverX+cellWidth/2, hoverY+cellHeight/2, objText) {
            text = '-$'+string(other.structureCost)
            color = c_red
            vspeed = -0.25
            destroyT = 30
            halign = fa_center
        }*/
        
        // Dust particles
        var d = 8
        var xc = hoverX+cellWidth/2
        var yc = hoverY+cellHeight/2
        scrCreatePoof(xc, yc)
        scrCreatePoof(xc-d, yc-d)
        scrCreatePoof(xc-d, yc+d)
        scrCreatePoof(xc+d, yc-d)
        scrCreatePoof(xc+d, yc+d)
        
        // Destroy existing rubble if there is any
        with instance_position(hoverX, hoverY, objRubble) {
            instance_destroy()
        }
        
    // Create "not enough money" floating text
    } else if mouse_check_button_pressed(mb_left) and okToPlacePhysical and not enoughMoney {
        
        with instance_create(hoverX+cellWidth/2, hoverY+cellHeight/2, objText) {
            text = 'not enough $'
            color = c_red
            vspeed = -0.25
            destroyT = 60
            halign = fa_center
        }
        
    // Create "not enough population" floating text
    } else if mouse_check_button_pressed(mb_left) and okToPlacePhysical and not populationOk {
        
        with instance_create(hoverX+cellWidth/2, hoverY+cellHeight/2, objText) {
            text = 'not enough people'
            color = c_red
            vspeed = -0.25
            destroyT = 60
            halign = fa_center
        }
    
    // Destroy buildings
    } else if mouse_check_button_pressed(mb_left) and structure == STRUCTURE.DESTROY {
        var toDestroy = instance_position(hoverX, hoverY, objCityCell)
        if toDestroy != noone {
            if toDestroy.object_index == objCityCellRoad {
                with instance_create(hoverX+cellWidth/2, hoverY+cellHeight/2, objText) {
                    text = "can't destroy roads"
                    color = c_red
                    vspeed = -0.25
                    destroyT = 60
                    halign = fa_center
                }
            } else {
                with toDestroy {
                    instance_destroy()
                    instance_create(x, y, objRubble)
                }
                
                audio_play_sound(sndBuildFactory, 0, false)
                success = true
                buttonSelected.visible = false
                buttonSelected = noone
                structure = STRUCTURE.ROAD
                
                // Dust particles
                var d = 8
                var xc = hoverX+cellWidth/2
                var yc = hoverY+cellHeight/2
                scrCreatePoof(xc, yc)
                scrCreatePoof(xc-d, yc-d)
                scrCreatePoof(xc-d, yc+d)
                scrCreatePoof(xc+d, yc-d)
                scrCreatePoof(xc+d, yc+d)
            }
        }
    } else if mouse_check_button_pressed(mb_left) and not okToPlacePhysical {
        with instance_create(hoverX+cellWidth/2, hoverY+cellHeight/2, objText) {
            if inFog {
                text = 'in fog'
            } else {
                text = "must touch road"
            }
            color = c_red
            vspeed = -0.25
            destroyT = 60
            halign = fa_center
        }
    }
    
    // Play error sound
    if mouse_check_button_pressed(mb_left) and not success {
        audio_play_sound(sndError, 0, false)
    }
}

// Stop suppressing indicator when we move our mouse away from the cell
// we just built on.
if suppressIndicatorLastPlaced and
    (hoverX != lastPlacedX or hoverY != lastPlacedY) {
    suppressIndicatorLastPlaced = false
}



// Scroll the camera

var scrollSpeed = 2
var edgeDist = 50 // How close to the edge the mouse must be to scroll

// Scroll the camera when you move your mouse to the edges
/*if scrMouseInWindow() {
    if mouse_x &lt; view_xview+edgeDist {
        view_xview -= scrollSpeed
    }
    if mouse_x &gt; view_xview+view_wview-edgeDist {
        view_xview += scrollSpeed
    }
    if mouse_y &lt; view_yview+edgeDist {
        view_yview -= scrollSpeed
    }
    if mouse_y &gt; view_yview+view_hview-edgeDist {
        view_yview += scrollSpeed
    }
}*/

// Scroll the camera with WASD
if keyboard_check(ord('A')) {
    view_xview -= scrollSpeed
}
if keyboard_check(ord('D')) {
    view_xview += scrollSpeed
}
if keyboard_check(ord('W')) {
    view_yview -= scrollSpeed
}
if keyboard_check(ord('S')) {
    view_yview += scrollSpeed
}

// Prevent scrolling way out into the abyss
var xMin = 10000
var yMin = 10000
var xMax = -10000
var yMax = -10000
with objFogBlocker {
    xMin = min(xMin, x)
    yMin = min(yMin, y)
    xMax = max(xMax, x)
    yMax = max(yMax, y)
}

var w = view_wview/2
var h = view_hview/2
var leeway = 128

view_xview = clamp(view_xview+w, xMin-leeway, xMax+leeway)-w
view_yview = clamp(view_yview+h, yMin-leeway, yMax+leeway)-h
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if not enabled or not readyToDraw {
    exit
}

if (buttonHover != noone) {
    // Button hover highlight
    draw_set_alpha(0.25)
    draw_set_color(c_white)
    var y2 = 30
    if (buttonHover.endButton) {
        y2 = 14
    }
    draw_rectangle(buttonHover.x+1, buttonHover.y+1, buttonHover.x+30, buttonHover.y+y2, false)
    draw_set_alpha(1)
    
    // Button tooltip
    if buttonHover.tooltip != '' {
        var xx = buttonHover.x+48
        var yy = buttonHover.y
    
        // Backing
        draw_set_color(c_black)
        draw_set_alpha(0.5)
        draw_rectangle(xx-8, yy-5, xx+188, yy+30, false)
        draw_set_alpha(1)
        draw_set_color(c_white)
        //draw_rectangle(xx-8, yy-5, xx+188, yy+30, true)
        
        // Text
        draw_set_font(scrGetFont(10))
        draw_set_halign(fa_left)
        draw_set_valign(fa_top)
        draw_set_color(c_white)
        draw_text(xx, yy, buttonHover.tooltip)
    }
}

// Selected button
with buttonSelected {
    draw_sprite(sprSelectedButton, 0, x, y)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if not enabled or not readyToDraw {
    exit
}

// Draw square outlines on available building tiles
for (var xx = view_xview; xx &lt; view_xview + view_wview + cellWidth; xx += cellWidth/2) {
    for (var yy = view_yview; yy &lt; view_yview + view_hview + cellHeight; yy += cellHeight/2) {
        var cellX = floor(xx/cellWidth)*cellWidth
        var cellY = floor(yy/cellHeight)*cellHeight
        
        var cellNextToRoad = not instance_position(cellX, cellY, objCityCell)
            and (instance_position(cellX+cellWidth, cellY, objCityCellRoad)
            or instance_position(cellX-cellWidth, cellY, objCityCellRoad)
            or instance_position(cellX, cellY+cellHeight, objCityCellRoad)
            or instance_position(cellX, cellY-cellHeight, objCityCellRoad))
        
        if cellNextToRoad {
            draw_sprite_ext(sprCellOutline, 0, cellX, cellY, 1, 1, 0, c_white, 0.25)
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Draw score
if objGameController.state == GAME_STATE.BUILD {
    draw_set_font(scrGetFont(10))
    draw_set_halign(fa_right)
    draw_set_valign(fa_top)
    scrDrawTextOutline(view_xview+view_wview-5, view_yview+5, string(numFactories)+' surviving factories', c_white, c_black)
}

if not enabled or not readyToDraw {
    exit
}

if not suppressIndicatorLastPlaced and not backingHover {
    // Flashing ghost
    ghost.image_alpha = 0.5
    if floor(animT/10) mod 2 == 0 and okToPlace {
        ghost.image_alpha = 1
    }
    with ghost {
        draw_self()
    }
    
    // Red or green squares
    for (var i=0; i&lt;2; i++) {
        var xx = hoverX+i*cellWidth
        for (var j=0; j&lt;2; j++) {
            var yy = hoverY+j*cellHeight
            
            if instance_position(xx, yy, objGhostCityCell) {
                draw_sprite_ext(sprCityCellNoPlace, okToPlace, xx, yy, 1, 1, 0, c_white, 1)
            }
        }
    }
    
    // Cost text
    if structure != STRUCTURE.DESTROY {
        draw_set_font(scrGetFont(10))
        draw_set_halign(fa_center)
        draw_set_valign(fa_top)
        var textColor = c_lime
        if money &lt; structureCost {
            textColor = c_red
        }
        scrDrawTextOutline(hoverX+cellWidth/2, hoverY+cellHeight/2, '$'+string(structureCost), textColor, c_black)
    }
}

// Scroll screen arrows
/*var arrowD = 12+3*sin(animT/60*pi*2)
var alpha = 1
if floor(animT/30) mod 2 == 0 {
    //alpha = 0
}
draw_sprite_ext(sprScrollArrow, 0, view_xview+view_wview-arrowD, view_yview+view_hview/2, 1, 1, 0, c_white, alpha)
draw_sprite_ext(sprScrollArrow, 0, view_xview+arrowD, view_yview+view_hview/2, 1, 1, 180, c_white, alpha)
draw_sprite_ext(sprScrollArrow, 0, view_xview+view_wview/2, view_yview+view_hview-arrowD, 1, 1, 270, c_white, alpha)
draw_sprite_ext(sprScrollArrow, 0, view_xview+view_wview/2, view_yview+arrowD, 1, 1, 90, c_white, alpha)*/

// Counters
var xx = view_xview+view_wview-80
var yy = view_yview+view_hview-48
draw_sprite(sprCountersBox, 0, xx, yy)

draw_set_font(scrGetFont(10))
draw_set_halign(fa_right)
draw_set_valign(fa_top)
draw_set_color(c_white)
draw_text(xx+74, yy+15, string(money))
draw_text(xx+74, yy+32, string(numIndustryAndCommercial)+'/'+string(population))

// WASD to move text
draw_set_font(scrGetFont(10))
draw_set_halign(fa_left)
draw_set_valign(fa_top)
scrDrawTextOutline(view_xview+8, view_yview+view_hview-20, 'WASD - camera', c_white, c_black)
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
